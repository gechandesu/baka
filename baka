#!/usr/bin/env bash

##########################################################################
#
#   baka
#
#   Do files and databases backup.
#
#
#   COPYING
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
##########################################################################

set -o errexit

baka_version=0.1.2

main_conf=/etc/baka/main.conf  # Default: /etc/baka/main.conf
baka_entries=/etc/baka/entries  # Default: /etc/baka/entries

bk_print_help() {
cat << EOF
Do files and databases backup.

Usage: baka [--version] [--help | help] <command> [<options>...]

Commands and options:
    backup                  do backup right now.
    list                    list backup entries.
    test                    test main configuration and all of entries.
    show                    print main configuration to STDOUT.
    edit                    edit main configuration in default editor..
    remove                  remove old backups.
    --version               print version and exit.
    --help, help            print this help message and exit.

See 'man baka' or 'baka <command> help' for more info.

        ,<baka!>
(#｀皿´)

Senpai wants you to do backups!

EOF
exit 0
}

bk_print_version() {
    echo "baka v$baka_version"
    exit 0
}

bk_getopts() {
    # GNU-style CLI options parser.
    #
    # Parse --opt VAL and --opt=VAL options.
    # Requires 2 arguments: $1, $2.
    # Returns:
    #   $opt - option name.
    #   $arg - option's value.
    #   $sft - value for shift.

    if [[ "$1" =~ .+=.+ ]]; then
        opt="${1%%=*}"; arg="${1#*=}"; sft=1
    elif [[ ! "$1" =~ .+=$ ]] && \
         [ "$2" ] && [ "${2:0:1}" != '-' ]
    then
        opt="$1"; arg="$2"; sft=2
    else
        opt="$1"
        if [[ "$1" =~ .+=$ ]]; then opt="${1:0: -1}"; fi
        bk_err -s "missing argument for: $opt"
    fi
}

bk_err() {
    # Show error message and write it into log.
    # $1 is error message.

    while (( "$#" ))
    do
        case "$1" in
            -s) # Don't write error log.
                local only_stderr=1; shift;;
            *) local err_message="$1" ; shift;;
        esac
    done

    local progname='baka'
    echo -e "$progname: $err_message" | sed 's/^ *//g' >&2
    [ "$only_stderr" ] || bk_log -n "Error: $err_message"
    exit 1
}

bk_error_report() {
    # Error reporting to email.
    # $1 is error message.
    # $mail_to must be set in main.conf.
    # This function is NOT USED.
    # TODO

    err_log_start="$( \
        grep -n '\[Started\]' "$log" | tail -1 | cut -d ':' -f 1 \
    )"  # Get log start line number.

    error_log="$(tail -n +"$err_log_start" "$log")"

    echo -e \
    "Error report $(date +"$log_df")\n\nMessage:\n$1\n\nLog:\n\n$error_log" \
    | mail -s "baka: Backup error: $HOSTNAME" "$mail_to"
}

bk_log() {
    # Logging.

    [[ "$#" > 2 ]] && echo "bk_log: Too many args." >&2
    while (( "$#" ))
    do
        case "$1" in
            -n) local no_print=1; shift;;
            *)  local log_message="$1"; shift;;
        esac
    done

    # If log message not sent as argument read stdin.
    if [[ ! "$log_message" ]]
    then
        local log_message="$(cat <&0)"
    fi

    # Don't write log if $log_message is empty.
    [[ "$log_message" == '' ]] && return 0

    # $1 is log message (can be multistring).
    local escaped_log_message="$( \
        printf '%s\n' "$log_message" | sed 's/[\/&]/\\&/g' \
    )"  # Escape log message.

    log_formatter() {
        # $1 - format string.
        # $2 - log string.
        sed -e \
        "s/%time/$(date +"$log_df")/g;s/%log/$2/g" <<< "$1"
    }

    while IFS= read -r log_line
    do
        if [ ! "$no_print" ]
        then
            echo -e "$log_message"
        fi
        log_formatter "$log_format" "$log_line" >> "$log"
    done <<< "$escaped_log_message"
}

bk_yn_dialog() {
    local question="$1"  # Message prompt.
    local yes=0
    local no=1
    local pending=2

    [ "$assume_yes" = "1" ] && return "$yes"

    local answer=$pending

    while [ $answer -eq $pending ]
    do
        echo -en "$question [y/n] "
        read -r reply
        case "$reply" in
            y|Y|Yes|YES) answer=$yes;;
            n|N|No|NO)   answer=$no;;
            *) echo 'Please, answer y or n';;
        esac
    done

    return "$answer"
}

bk_check_rsync() {
    if hash rsync 2>/dev/null
    then
        rsync_bin=/usr/bin/rsync
    else
        bk_err -s 'rsync executable not found.'
    fi
}

bk_check_s3cmd() {
    if hash s3cmd 2>/dev/null
    then
        # If s3cmd is installed via OS package manager.
        s3cmd_bin=/usr/bin/s3cmd
    elif [ -f /usr/local/bin/s3cmd ]
    then
        # If s3cmd is installed globally via Python pip.
        s3cmd_bin=/usr/local/bin/s3cmd
    else
        bk_err -s 's3cmd executable not found.'
    fi
}

# CONFIG PARSER
##########################################################################

bk_read_config() {
    # Read file passed as $1 and parse lines. Return clean config.
    #
    # - Remove spaces and tabs across '='
    # - Remove comments ('#')
    # - Remove blank lines
    # - Escape whitespaces and special characters
    local bk_config="$(sed \
        's/[[:space:]]\+=[[:space:]]\+/=/g;/^#/d;/^$/d;s/#.*//g' <(\
        cat "$1" | grep = \
    ) | while read -r LN; do echo $(printf '%q' "$LN"); done)"
    echo "$bk_config"
}

bk_parse_main_conf() {
    # Main baka config parser.
    if ! [ -f "$main_conf" ]
    then
        bk_err -s "$main_conf: file not found."
    fi

    eval "$(bk_read_config "$main_conf")"

    # Check the minimal set of parameters.
    if [[ \
     "$log"         && \
     "$log_df"      && \
     "$log_format"  && \
     "$df"          && \
     "$nf"          && \
     "$remote"      && \
     "$livetime"    \
    ]]
    then
        :  # Do nothing if all set.
    else
        bk_err -s \
            "Some required parameters is not set. Check $main_conf
            See 'man baka' for more info."
    fi

    # Check remote storage settings.
    if [ "$remote" = 'none' ]  # Do nothing if set to 'none'.
    then
        :  # Do nothing.
    elif [ "$remote" = 'rsync' ] # Check rsync and optional params.
    then
        bk_check_rsync
        if [ ! "$ssh_uri" ]
        then
            bk_err -s "You set rsync for copy to remote storage, but
            ssh_uri is not set. Please, check $main_conf"
        fi
    elif [ "$remote" = 's3' ]  # Check s3cmd and optional params.
    then
        bk_check_s3cmd
        if [ ! "$s3_uri" ]
        then
            bk_err -s "You set s3 for copy to remote storage, but
            s3_uri is not set. Please, check $main_conf"
        fi
    else  # Exit if 'remote' has another value.
        bk_err -s "$main_conf: $remote: bad value. See 'man baka' for info."
    fi
}

bk_find_entries() {
    # Return array '$bk_all_entries'with files
    # from /etc/baka/entries ($baka_entries). Resolve symlinks too.
    local all_files="$(find "$baka_entries" -type f)"

    for file in $all_files
    do
        # Resolve symlinks.
        if [ -L "$file" ]; then
            s="$(readlink "$file")"
            if [ -f "$s" ]; then
                file="$s"
            fi
        fi
        # Collect all entries, except ignored if set.
        if [[ ! "${ignore[@]}" =~ "$(basename $file)" ]]
        then
            bk_all_entries+=("$file")
        fi
    done

    # Exit if nothing found.
    if [[ "${#bk_all_entries[@]}" == 0 ]]
    then
        bk_err "$baka_entries: no entries to backup."
    fi

    # SECURITY ISSUE FIX.
    #
    # Check entries and main.conf permissions.
    for item in "$bk_all_entries" "$main_conf"
    do
        if [[ "$(stat -c "%a" "$item")" > 644 ]]
        then
            bk_err "$item: permissions are too open
        It is recommended that your configurations are NOT accessible by others."
        else
        :
        fi
    done
}

bk_selected_entries() {
    for entry in ${entries[@]}
    do
        entry="$baka_entries"/"$entry"
        if [ -f "$entry" ]
        then
            bk_all_entries+=("$entry")
        else
            bk_err "$entry: file not found."
        fi
    done
}

bk_parse_baka_entry() {
    # Parse single entry file from $baka_entries dir.
    # $1 is entry filename.
    local bk_entry="$(bk_read_config "$1")"

    if [ "$local" ]; then
        dest_dir="$local"
    else
        dest_dir="$( \
            awk -F '=' '/dest/ {print $2}' <<< "$bk_entry" \
        )"
        # Check the dest parameter.
        if [[ $(grep -c dest <<< "$bk_entry") == 0 ]]
        then
            bk_err "$1: 'dest' parameter is not set."
        elif [[ $(grep -c dest <<< "$bk_entry") > 1 ]]
        then
            bk_err "$1: double 'dest' parameter."
        elif [ ! -d "$dest_dir" ]
        then
            bk_err "$1: $dest_dir: destination dir does not exist"
        fi
    fi

    # Check other parameters.
    if [[ ! $( \
        egrep "files|postgres|mysql|command" <<< "$bk_entry" \
    ) ]]
    then
        bk_err "$1: no data to backup.
            Please set files, databases or commands in $1.
            See 'man baka' for more info."
    fi
}

bk_get_entry_data() {
    # Returns array of entry parameter values.
    # For example you wrote 3 different database requisites
    # in /etc/baka/entries/example.conf:
    #   mysql = db1:user1:pass1
    #   mysql = db2:user2:pass2
    #   mysql = db3:user3:pass3
    # You receive array:
    #   bk_mysql = ( db1:user1:pass1 db2:user2:pass2 db3:user3:pass3 )
    # 
    # Parameters for this function:
    #   $1 is entry file (path).
    #   $2 is search query (e.g.: mysql, postgres, files, etc.).

    eval "bk_$2=()"  # Set empty data to prevent dublicates.

    # Parse file.
    entry_data="$(bk_read_config "$1")"

    # Collect values.
    local raw_values="$(
        grep "$2" <<< "$entry_data" \
        | awk -F '=' '{for(i=2;i<=NF;i++){printf "%s ", $i}}' \
    )"

    for value in "$raw_values"
    do
        eval "bk_$2+=("$value")"
    done
}

bk_parse_nf() {
    # Parse name format.
    # Refference:
    #   %type
    #       'backup' for files or 'dump' for databases.
    #   %name
    #       directory or database name.
    #   %time
    #       datetime formatted by 'df' option.
    #   Example:
    #   nf  = '%type_%name_%time'

    local type="$1"
    local name="$(basename "$2")"

    sed "s/%type/$type/g;
         s/%name/$name/g;
         s/%time/$(date +"$df")/g" <<< "$nf"
}

bk_parse_db_reqs() {
    # Database requisites parser.
    # $1 is string with semicolon separated requisites.

    # Characters : (semicolon) and # (hash)
    # is not allowed in database passwords!
    # Password will be broken after parsing.

    local entry_count=$(awk -F: '{print NF}' <<< "$1")

    if [ "$entry_count" -eq 5 ]; then
        db_host=$(cut -d ':' -f 1 <<< "$1")
        db_port=$(cut -d ':' -f 2 <<< "$1")
        db_name=$(cut -d ':' -f 3 <<< "$1")
        db_user=$(cut -d ':' -f 4 <<< "$1")
        db_pass=$(cut -d ':' -f 5 <<< "$1")
    elif [ "$entry_count" -eq 4 ]; then
        db_host=$(cut -d ':' -f 1 <<< "$1")
        # db_port will be set later.
        db_name=$(cut -d ':' -f 2 <<< "$1")
        db_user=$(cut -d ':' -f 3 <<< "$1")
        db_pass=$(cut -d ':' -f 4 <<< "$1")
    elif [ "$entry_count" -eq 3 ]; then
        db_host=localhost
        # db_port will be set later.
        db_name=$(cut -d ':' -f 1 <<< "$1")
        db_user=$(cut -d ':' -f 2 <<< "$1")
        db_pass=$(cut -d ':' -f 3 <<< "$1")
    else
        bk_err "$1: bad database requisites.
        Correct syntax is host:port:db:user:pass. See docs for more info."
    fi
}

bk_show_db_reqs() {
    # $1 is password show/hide flag.
    echo "Host:     $db_host"
    echo "Port:     $db_port"
    echo "Database: $db_name"
    echo "User:     $db_user"
    if [ "$1" ]
    then
        echo "Password: $db_pass"
    else
        echo "Password: hidden"
    fi
    echo "---"
}

#   BACKUP
##########################################################################

bk_do_backup_help() {
cat << EOF
Do backup.

Usage: baka backup [--help | help] [-i | --ignore=<entry>]
                   [-e | --entry=<entry>] [--local] [--no-verify]
                   [--remove]
Options:
    -i, --ignore=<entry>    run backup for all entries, except ignored.
    -e, --entry=<entry>     run backup for selected entry.
    --local                 force local backup.
    --no-verify             don't check archives integrity.
    --remove                remove old backups (forced).
    --help, help            print this message and exit.
EOF
exit 0
}

bk_backup_files() {

    bk_exclude_items() {
        # Exclude files and directories from backup.
        for items in ${bk_exclude[*]}
        do
            items="$( tr ',' ' ' <<< "$items")"
            for item in $items; do
                echo -en "--exclude='$item' "
            done
        done
    }

    for filepath in "${bk_files[@]}"
    do
        if [ -f "$filepath" ] || [ -d "$filepath" ]
        then
            :
        else
            bk_err "$filepath: no such file or directory."
        fi

        echo "Archiving files: $filepath ..." | bk_log

        # Archive name. $filepath is path set in /etc/baka/entries/* in 'files'.
        dest_file="$dest_dir"/"$(bk_parse_nf backup "$filepath")".tar.gz

        # Do archive!
        eval \
            tar -czf "$dest_file" $(bk_exclude_items) \
            -C $(dirname "$filepath") $(basename "$filepath") \
            |& bk_log -n

        bk_log "Archiving files: $filepath [Done]"

        # Verifying.
        if [ ! "$no_verify" ]; then
            if gunzip -c "$dest_file" | tar -t > /dev/null
            then
                bk_log "Integrity (gzip uncompressing and tar -t) [Success]"
            else
                bk_log "Integrity (gzip uncompressing and tar -t) [Fail]"
            fi

            local in_dir="$(find "$filepath" | wc -l)"
            local in_tar="$(tar -tf "$dest_file" | wc -l)"

            if [[ "$in_dir" == "$in_tar" ]]
            then
                bk_log \
                "Completeness: items: $in_dir, archived: $in_tar [Success]"
            elif [[ "${#bk_exclude[@]}" != 0 ]]
            then
                echo "Completeness: Some files is excluded by configuration:
                items: $in_dir, archived: $in_tar [Skipped]" \
                | sed 's/^ *//g' | tr '\n' ' ' | bk_log
            else
                bk_err \
                "Completeness: items: $in_dir, archived: $in_tar [Failed]"
            fi
        else
            :  # Don't verify.
        fi

        bk_log "Archive saved as: $dest_file"
        bk_upload_file "$dest_file"
    done
}

bk_run_command() {
    # Run commands listed in entry. Disabled by default.
    # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    # IT'S DANGEROUS! DON'T USE UNTRUSTED COMMANDS IN ENTRY!
    # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    if [[ "$allow_commands" == "true" ]]
    then
        for command in "${bk_command[@]}"
        do
            bk_log "Executing command: $command"
            # Run!
            eval "$(printf "$command")"
        done
    else
        bk_log "Error: tried to execute commands: ${bk_command[@]}"
        bk_err "Commands executing is not allowed!"
    fi
}

bk_backup_mysql() {
    # Do MariaDB/MySQL dump.

    for reqs in "${bk_mysql[@]}"
    do
        bk_parse_db_reqs "$reqs"

        bk_log "Dumping database: $db_name@$db_host (MySQL) ..."

        dump_name="$dest_dir"/"$(bk_parse_nf dump "$db_name")".sql.gz
        [ "$db_port" ] || db_port=3306  # Set default MySQL port.

        mysqldump \
            --host="$db_host" \
            --port="$db_port" \
            "$db_name" \
            --user="$db_user" \
            --password="$db_pass" \
            | gzip -c > "$dump_name" |& bk_log

        if [ -s "$dump_name" ]; then
            bk_log "Dumping database: $db_name@$db_host (MySQL) [Done]"
            bk_log "Dump saved as: $dump_name"
            bk_upload_file "$dump_name"
        else
            rm "$dump_name"
            bk_err "Something went wrong. Dump size is 0 bytes. Removing $dump_name"
        fi
    done
}

bk_backup_postgres() {
    # Do PostgreSQL dump.

    for reqs in "${bk_postgres[@]}"
    do
        bk_parse_db_reqs "$reqs"

        bk_log "Dumping database: $db_name@$db_host (PostgreSQL) ..."

        dump_name="$dest_dir"/"$(bk_parse_nf dump "$db_name")".psql.gz
        [ "$db_port" ] || db_port=5432  # Set default PostgreSQL port.
        export PGPASSWORD="$db_pass"

        pg_dump \
            --host="$db_host" \
            --port="$db_port" \
            --dbname="$db_name" \
            --username="$db_user" \
            --no-password | gzip -c > "$dump_name" |& bk_log

        unset PGPASSWORD

        if [ -s "$dump_name" ]; then
            bk_log "Dumping database: $db_name@$db_host (PostgreSQL) [Done]"
            bk_log "Dump saved as: $dump_name"
            bk_upload_file "$dump_name"
        else
            rm "$dump_name"
            bk_err "Something went wrong. Dump size is 0 bytes. Removing $dump_name"
        fi
    done
}

bk_upload_via_rsync() {
    # RSYNC
    local filename="$1"
    [ "$ssh_port" ] || ssh_port=22
    rsync -a -e "ssh -p $ssh_port" "$filename" "$ssh_uri" | bk_log
}

bk_upload_via_s3cmd() {
    # S3
    local filename="$1"
    s3cmd -pq --no-progress put "$filename" "$s3_uri" | bk_log
}

bk_upload_file() {
    # Select function to upload.
    #
    # $1 -- file passed to upload.

    if [ "$remote" == 'none' ]; then
        :
    else
        bk_log "Uploading ${1##*/} to remote server ..."
        case "$remote" in
            rsync) bk_upload_via_rsync "$1";;
            s3) bk_upload_via_s3cmd "$1";;
        esac
        bk_log "Uploading ${1##*/} [Done]"
    fi
}

bk_do_backup() {
    # Main function for 'backup' command.

    # Parse args.
    if [[ "$@" =~ -i|--i ]] && [[ "$@" =~ -e|--e ]]
    then
        bk_err \
        "You can not use '--ignore' and '--entry' options together.
        See 'baka backup help' or 'man baka' for more info."
    fi

    while (( "$#" ))
    do
        case "$1" in
            -i|--ignore|--ignore=*)
                bk_getopts "$1" "$2"
                ignore+=("$arg")
                shift "$sft";;
            -e|--entry|--entry=*)
                bk_getopts "$1" "$2"
                entries+=("$arg")
                shift "$sft";;
            --no-verify) no_verify=1; shift;;
            --local) no_remote=1; shift;;
            --remove) remove_backups=1; shift;;
            --help|help)
                bk_do_backup_help;;
            *) bk_err -s "bad option: $1";;
        esac
    done

    # Startup log.
    bk_log -n "Backup [Started]"
    echo "Backup: $(date +"$log_df")"
    bk_log \
    "Destination dir (local): $([ $local ] && echo $local || echo 'from entry')"

    # Force local backup ('--local' option).
    if [ "$no_remote" ]; then
        remote='none'
        bk_log \
        "Local backup forced! Files does not be uploaded to remote storage."
    fi

    bk_log "Remote transport: $remote"
    case "$remote" in
        none) remote_uri='none';;
        s3) remote_uri=$s3_uri;;
        rsync) remote_uri=$ssh_uri;;
    esac
    bk_log "Remote URI: $remote_uri"

    # Start entries processing.
    if [ "$entries" ]  # --entry option.
    then
        bk_selected_entries
        # Selected entries basenames.
        # Used only for display in echo below.
        local seb="$( \
            for ent in ${bk_all_entries[@]}
            do echo -n "$(basename $ent) "; done
        )"
        echo "Selected entries: $seb" | bk_log
    else
        [ "$ignore" ] && \
            echo "Skipped entries: ${ignore[@]}" | bk_log
        bk_find_entries
    fi

    # Non printing log.
    echo \
    "Entries to backup (${#bk_all_entries[@]}): ${bk_all_entries[@]}" | bk_log -n

    # Entry counter.
    ecnt=${#bk_all_entries[@]} # Entries count.
    iter=1  # Iterator.

    # For every entry in $baka_entries ...
    for entry in "${!bk_all_entries[@]}"
    do
        # Display entry name and counter.
        # Output: -> Entry: example.org [1/5]
        echo
        bk_log \
        "-> Entry: ${bk_all_entries[iter-1]##*/} [$(($entry+1))/$ecnt]"

        bk_parse_baka_entry "${bk_all_entries[iter-1]}"

        # Get data.
        # 'dest' is already parsed in bk_parse_baka_entry().
        bk_get_entry_data "${bk_all_entries[iter-1]}" 'files'
        bk_get_entry_data "${bk_all_entries[iter-1]}" 'exclude'
        bk_get_entry_data "${bk_all_entries[iter-1]}" 'command'
        bk_get_entry_data "${bk_all_entries[iter-1]}" 'mysql'
        bk_get_entry_data "${bk_all_entries[iter-1]}" 'postgres'

        bk_log "Destination dir: $dest_dir"

        # Do backups!
        if [[ "${#bk_command[@]}" != 0 ]]; then
            bk_run_command
        fi
        if [[ "${#bk_files[@]}" != 0 ]]; then
            bk_backup_files
        fi
        if [[ "${#bk_mysql[@]}" != 0 ]]; then
            bk_backup_mysql
        fi
        if [[ "${#bk_postgres[@]}" != 0 ]]; then
            bk_backup_postgres
        fi

        let iter++  # Increase iterator for entry counter.
    done

    # Remove old backups ('--remove' option).
    if [ "$remove_backups" ]; then
        echo
        echo "-> Remove old backups ..."
        bk_get_dest_dirs  # Get $dest_dirs
        for dir in "${dest_dirs[@]}"
        do
            bk_delete_files "$dir"
        done
    fi

    echo  # Just print new line.
    bk_log "Backup [Finished]"
}

#   OTHER OPTIONS
##########################################################################

#   BAKA LIST
#   Show entries list.
######################

bk_show_list_help() {
cat << EOF
Show entries list.

Usage: baka list [--help | help] [-v| --verbose] [-s| --short] [-S]

Options:
    -v, --verbose   print entries list verbosely (default).
    -s, --short     short format (names).
    -S              short format (pathes).
    --help, help    print this message and exit.
EOF
exit 0
}

bk_show_list() {

    verbose_list=2  # Default view mode.

    while (( "$#" ))
    do
        case "$1" in
            -v|--verbose) verbose_list=2; shift;;
            -s|--short) verbose_list=1; shift;;
            -S) verbose_list=0; shift;;
            --help|help)
                bk_show_list_help;;
            *) bk_err -s "bad option: $1";;
        esac
    done

    bk_find_entries  # Get entries list.

    if [ "$verbose_list" -eq 2 ]; then
        # Verbosely.
        for entry in "${bk_all_entries[@]}"
        do
            echo -e "${entry##*/}\t($entry)"
        done
    elif [ "$verbose_list" -eq 1 ]; then
        # Short format (names).
        for entry in "${bk_all_entries[@]}"
        do
            echo "${entry##*/}"
        done
    elif [ "$verbose_list" -eq 0 ]; then
        # Short format (pathes).
        for entry in "${bk_all_entries[@]}"
        do
            echo "$entry"
        done
    fi
}

#   BAKA TEST
#   Test all entries.
#####################

bk_do_test_help() {
cat << EOF
Do tests.

Usage: baka test [--help | help] [-v| --verbose] 

Options:
    -v, --verbose   print output verbosely.
    --help, help    print this message and exit.
EOF
exit 0
}

bk_do_test() {

    while (( "$#" ))
    do
        case "$1" in
            -v|--verbose) verbose_test=1; shift;;
            --help|help)
                bk_do_test_help;;
            *) bk_err -s "bad option: $1";;
        esac
    done

    bk_find_entries  # Get entries list.

    echo  # Just print new line.

    # Entry counter.
    ecnt=${#bk_all_entries[@]} # Entries count.
    iter=1  # Iterator.

    for entry in "${!bk_all_entries[@]}"
    do

        # Display entry name and counter.
        # Output: -> Entry: example.org [1/2]
        echo \
        "-> Entry: ${bk_all_entries[iter-1]##*/} [$(($entry+1))/$ecnt]"

        bk_parse_baka_entry "${bk_all_entries[iter-1]}"
        bk_get_entry_data "${bk_all_entries[iter-1]}" 'files'
        bk_get_entry_data "${bk_all_entries[iter-1]}" 'exclude'
        bk_get_entry_data "${bk_all_entries[iter-1]}" 'command'
        bk_get_entry_data "${bk_all_entries[iter-1]}" 'mysql'
        bk_get_entry_data "${bk_all_entries[iter-1]}" 'postgres'
        [ "$verbose_test" ] && echo "Parse entry: OK"

        # Files checking.
        for path in "${bk_files[@]}"
        do
            if [ -f "$path" ] || [ -d "$path" ]; then
                [ "$verbose_test" ] && echo "Files: OK"
            else
                bk_err "$path: path does not exist"
            fi
        done

        # MySQL checking.
        [ "$db_port" ] || db_port=3306  # Set default MySQL port.
        for reqs in "${bk_mysql[@]}"
        do
            bk_parse_db_reqs "$reqs"

            [ "$verbose_test" ] && \
                echo -n "Checking database $db_name@$db_host (MySQL): "

            echo 'show variables like "%version%";' \
            | mysql \
                --host="$db_host" \
                --port="$db_port" \
                "$db_name" \
                --user="$db_user" \
                --password="$db_pass" > /dev/null

            [ "$verbose_test" ] && echo "OK"
        done

        # PostgreSQL checking.
        for reqs in "${bk_postgres[@]}"
        do
            bk_parse_db_reqs "$reqs"

            [ "$verbose_test" ] && \
            echo -n "Checking database: $db_name@$db_host (PostgreSQL): "

            [ "$db_port" ] || db_port=5432  # Set default PostgreSQL port.
            export PGPASSWORD="$db_pass"

            echo 'select version();' \
            |psql \
                --host="$db_host" \
                --port="$db_port" \
                --dbname="$db_name" \
                --username="$db_user" \
                --no-password > /dev/null

            [ "$verbose_test" ] && echo "OK"
            unset PGPASSWORD
        done

        let iter++  # Increase iterator for entry counter.
        echo  # Just print new line.
    done

    if [ "$remote" == 'none' ]; then
        :
    else
        echo "-> Remote server testing ..."
        echo 'This is baka test file' > ./testfile
        [ "$verbose_test" ] && echo "Test file uploading ..."
        case "$remote" in
            rsync)
                bk_upload_via_rsync ./testfile
                [ "$verbose_test" ] && \
                    echo "Test file uploaded successfully."
                [ "$verbose_test" ] && \
                    echo "Removing test file ..."
                ssh -p "$ssh_port" "${ssh_uri%%:*}" "rm ${ssh_uri##*:}/testfile"
                ;;
            s3)
                bk_upload_via_s3cmd ./testfile
                [ "$verbose_test" ] && \
                    echo "Test file uploaded successfully."
                [ "$verbose_test" ] && \
                    echo "Removing test file ..."
                s3cmd -pq --no-progress del "$s3_uri"/testfile
                ;;
        esac
        rm ./testfile
        echo
    fi
    echo "Test is successful!"
}


#   BAKA SHOW
#############

bk_edit_help() {
# TODO
cat << EOF
Show configuration.

Usage: baka show [--help | help] [<entry>]

Options:
    --help, help    print this message and exit.

Configuration file prints without comments. To view $main_conf just run
'baka show'. Also you can view a specific entry passed as argument.
EOF
exit 0

}
bk_show_config() {
    bk_read_config "$main_conf"
    exit 0
}

#   BAKA EDIT
#############

bk_edit_help() {
# TODO
cat << EOF
Edit configuration in default editor.

Usage: baka edit [--help | help] [<entry>]

Options:
    --help, help    print this message and exit.

For edit $main_conf just run 'baka edit'. Also you can edit
a specific entry passed as argument.
EOF
exit 0
}

bk_edit_config() {

    get_selected_editor() {
        source $HOME/.selected_editor
        echo $SELECTED_EDITOR
    }

    # Detect default editor.
    if [ "$EDITOR" ]; then
        local e=$EDITOR
    elif [ -f $HOME/.selected_editor ]; then
        local e="$(get_selected_editor)"
    elif [ -f /usr/bin/select-editor ]; then
        select-editor
        local e="$(get_selected_editor)"
    else
        local e=/usr/bin/vi
    fi

    # Open file in editor.
    echo "Edit $main_conf"
    "$e" "$main_conf"
}

#   BAKA REMOVE
#   Remove old backups.
#######################


bk_remove_backups_help() {
cat << EOF
Remove old local backups (older than $livetime days).
Backup livetime is set in $main_conf

Usage: baka remove [--help | help] [-f|--force]

Options:
    -f, --force     force remove.
    --help, help    show this message and exit.
EOF
exit 0
}

bk_delete_files() {
    # DELETE FILES.
    #
    # $1 is directory for search.
    bk_log -n "Removing old backups (older than $livetime days) ..."
    bk_log -n "Removing files from directory: $1"
    find "$1" -regextype posix-extended \
              -regex "(.+)\.(tar.gz|sql.gz|psql.gz)" \
              -type f -mtime +$livetime -delete -print | bk_log
    echo '(empty output -- no files deleted)'
}

bk_get_dest_dirs() {
    # Return destination directories list for remove_backups()
    # function.
    bk_find_entries  # Get entries list.

    for entry in "${bk_all_entries[@]}"
    do
        bk_parse_baka_entry "$entry"
        dest_dirs+=("$dest_dir")
    done

    # Remove doubles.
    local temp="$(\
        tr ' ' '\n' <<< "${dest_dirs[@]}" | sort -u | tr '\n' ' ' \
    )"
    dest_dirs=()
    for item in $temp
    do
        dest_dirs+=("$item")
    done
}

bk_remove_backups() {

    while (( "$#" ))
    do
        case "$1" in
            -f|--force) force_remove=1; shift;;
            --help|help)
                bk_remove_backups_help;;
            *) bk_err -s "bad option: $1";;
        esac
    done

    bk_get_dest_dirs  # Get $dest_dirs

    if [ "$force_remove" ]; then
        echo "Removing forced!"
        for dir in "${dest_dirs[@]}"
        do
            bk_delete_files "$dir"
        done
        exit 0
    fi

    # Show prompt.
    echo \
    "Files older than $livetime days will be removed. This action cannot be undone."
    echo "Use '--force' option to remove files without prompt."
    echo
    if bk_yn_dialog "Continue?"
    then
        for dir in "${dest_dirs[@]}"
        do
            bk_delete_files "$dir"
        done
    else
        echo 'Abort.'; exit 1
    fi
}

#   ARG PARSER
##########################################################################

bk_parse_main_conf  # Read configuration before anything.

# Parse arguments.
[[ "$@" ]] || bk_print_help

while (( "$#" ))
do
    case "$1" in
        backup)
            shift; bk_do_backup "$@"; shift "$#";;
        list)
            shift; bk_show_list "$@"; shift "$#";;
        test)
            shift; bk_do_test "$@"; shift "$#";;
        show)
            bk_show_config; shift;;
        edit)
            bk_edit_config; shift;;
        remove)
            shift; bk_remove_backups "$@"; shift "$#";;
        --version)
            bk_print_version;;
        --help|help)
            bk_print_help;;
        *)
            bk_err -s "Unknown command: $1\nSee 'baka help' or 'man baka' for info."
    esac
done
